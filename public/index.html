<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DrumVoice - Voice-Only Assistant for Drummers</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #0f1419 0%, #0a0e13 70%, #040608 100%);
            color: #e8f4f8;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            font-weight: 300;
        }

        .header {
            background: rgba(15, 20, 25, 0.95);
            padding: 20px 24px;
            text-align: center;
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 215, 0, 0.15);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        .header h1 {
            font-size: 2.4em;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffc107 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .header p {
            opacity: 0.8;
            font-size: 1.1em;
            font-weight: 400;
            color: #b8d4da;
        }

        .main-container {
            display: flex;
            flex: 1;
            gap: 20px;
            padding: 20px;
            min-height: 0;
        }

        .left-panel {
            width: 420px;
            background: rgba(25, 35, 45, 0.6);
            border-radius: 12px;
            padding: 30px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 215, 0, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .right-panel {
            flex: 1;
            background: rgba(25, 35, 45, 0.6);
            border-radius: 12px;
            padding: 24px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 215, 0, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .section-title {
            font-size: 1.3em;
            font-weight: 500;
            color: #ffd700;
            margin-bottom: 20px;
            text-align: center;
            letter-spacing: 0.5px;
        }

        .voice-control {
            text-align: center;
        }

        .mic-button {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 50%, #1d4ed8 100%);
            color: white;
            font-size: 3em;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 12px 35px rgba(59, 130, 246, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        .mic-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, transparent 0%, rgba(255, 215, 0, 0.1) 50%, transparent 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mic-button:hover {
            transform: translateY(-4px);
            box-shadow: 0 16px 45px rgba(59, 130, 246, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .mic-button:hover::before {
            opacity: 1;
        }

        .mic-button.recording {
            background: linear-gradient(135deg, #dc2626 0%, #ef4444 50%, #b91c1c 100%);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }

            70% {
                box-shadow: 0 0 0 25px rgba(239, 68, 68, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        .voice-status {
            font-size: 1.1em;
            color: #94a3b8;
            margin-top: 15px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .metronome-section {
            text-align: center;
        }

        .metronome-display {
            background: rgba(15, 20, 25, 0.8);
            padding: 30px;
            border-radius: 15px;
            margin: 20px 0;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .bpm-display {
            font-size: 3.5em;
            font-weight: 700;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .beat-indicator {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: rgba(30, 41, 59, 0.8);
            margin: 20px auto;
            transition: all 0.15s ease;
            border: 3px solid rgba(71, 85, 105, 0.5);
            box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .beat-indicator.flash {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            border-color: #3b82f6;
            box-shadow: 0 0 25px rgba(59, 130, 246, 0.6), inset 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .beat-indicator.accent {
            background: linear-gradient(135deg, #ffd700 0%, #f59e0b 100%);
            border-color: #ffd700;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.6), inset 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .subdivision-display {
            font-size: 1.1em;
            color: #94a3b8;
            margin-top: 15px;
            font-weight: 400;
        }

        .tap-tempo-section {
            text-align: center;
            background: rgba(15, 20, 25, 0.5);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.1);
        }

        .timer-section {
            text-align: center;
            background: rgba(15, 20, 25, 0.5);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.1);
        }

        .timer-display {
            background: rgba(15, 20, 25, 0.8);
            padding: 24px;
            border-radius: 15px;
            margin: 16px 0;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .time-display {
            font-size: 3em;
            font-weight: 700;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .time-subtext {
            font-size: 0.95em;
            color: #94a3b8;
        }

        .timer-inputs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .timer-text {
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid rgba(71, 85, 105, 0.3);
            background: rgba(30, 41, 59, 0.7);
            color: #e2e8f0;
            font-size: 0.95em;
            min-width: 160px;
        }

        .tap-indicator {
            font-size: 1.2em;
            margin: 12px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #cbd5e1;
            text-align: center;
        }

        .tap-count {
            font-size: 1em;
            color: #94a3b8;
        }

        .controls {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: rgba(30, 41, 59, 0.7);
            color: #e2e8f0;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: all 0.2s ease;
            border: 1px solid rgba(71, 85, 105, 0.3);
            backdrop-filter: blur(10px);
        }

        .control-btn:hover {
            background: rgba(51, 65, 85, 0.8);
            border-color: rgba(255, 215, 0, 0.3);
            transform: translateY(-1px);
        }


        .control-btn.active {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            border-color: #3b82f6;
            color: white;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .voice-commands-help {
            background: rgba(15, 20, 25, 0.6);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.1);
        }

        .command-category {
            margin-bottom: 15px;
        }

        .command-category h4 {
            color: #ffd700;
            font-size: 0.9em;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .command-list {
            color: #cbd5e1;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .pdf-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .pdf-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px 0;
        }

        .page-info {
            font-size: 1.2em;
            color: #ffd700;
            font-weight: 500;
            text-align: center;
        }

        .pdf-viewer {
            flex: 1;
            border-radius: 10px;
            overflow: hidden;
            background: rgba(15, 20, 25, 0.8);
            border: 1px solid rgba(255, 215, 0, 0.2);
            position: relative;
            min-height: 400px;

            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        .pdf-upload-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            gap: 25px;
            color: #64748b;
            padding: 40px;
        }

        .pdf-upload-icon {
            font-size: 4em;
            opacity: 0.6;
        }

        .upload-instruction {
            font-size: 1.3em;
            font-weight: 500;
            color: #cbd5e1;
            text-align: center;
        }

        .upload-description {
            font-size: 1em;
            color: #64748b;
            text-align: center;
            max-width: 350px;
            line-height: 1.5;
        }

        .voice-only-note {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            padding: 15px 25px;
            border-radius: 25px;
            color: white;
            font-weight: 500;
            font-size: 1em;
            text-align: center;
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3);
        }

        #pdfContent {
            width: 100%;
            height: 100%;
            display: none;
            overflow: auto;
            background: #ffffff;
        }

        #pdfCanvas {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .console-section {
            background: rgba(15, 20, 25, 0.9);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            max-height: 250px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', 'Fira Code', 'Courier New', monospace;
            border: 1px solid rgba(255, 215, 0, 0.1);
        }

        .console-title {
            color: #ffd700;
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .console-log {
            margin-bottom: 10px;
            padding: 8px 0;
            border-left: 3px solid rgba(59, 130, 246, 0.4);
            padding-left: 15px;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .log-timestamp {
            color: #64748b;
            font-size: 0.8em;
        }

        .log-command {
            color: #fbbf24;
            margin: 3px 0;
            font-weight: 500;
        }

        .log-action {
            color: #60a5fa;
            margin: 3px 0;
        }

        .status-bar {
            background: rgba(15, 20, 25, 0.95);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid rgba(255, 215, 0, 0.15);
            font-size: 1em;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #94a3b8;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #475569;
            transition: background 0.3s ease;
        }

        .status-dot.online {
            background: #10b981;
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.4);
        }

        #lastCommand {
            color: #cbd5e1;
            font-style: italic;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 1.1em;
        }

        .hidden-input {
            position: absolute;
            left: -9999px;
            opacity: 0;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(15, 20, 25, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 215, 0, 0.5);
        }

        /* Mobile Responsiveness */
        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
                gap: 15px;
            }

            .left-panel {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>ü•Å DrumVoice</h1>
        <p>Voice-Only Assistant for Professional Drummers</p>
    </div>

    <div class="main-container">
        <div class="left-panel">
            <!-- Voice Control -->
            <div class="voice-control">
                <h2 class="section-title">Voice Control</h2>
                <button class="mic-button" id="micButton">üé§</button>
                <div class="voice-status" id="voiceStatusText">Click microphone to start voice control</div>
            </div>

            <!-- Metronome -->
            <div class="metronome-section">
                <h2 class="section-title">Metronome</h2>
                <div class="metronome-display">
                    <div class="bpm-display" id="bpmDisplay">120</div>
                    <div class="beat-indicator" id="beatIndicator"></div>
                    <div class="subdivision-display" id="subdivisionDisplay">Eighth Notes</div>
                </div>

                <div class="controls">
                    <button class="control-btn" id="playBtn">‚ñ∂Ô∏è Start</button>
                    <button class="control-btn" id="stopBtn">‚èπÔ∏è Stop</button>
                </div>
            </div>

            <!-- Tap Tempo Section -->
            <div class="tap-tempo-section">
                <h3 class="section-title" style="font-size: 1.1em;">Tap Tempo (by voice)</h3>
                <div class="tap-indicator" id="tapIndicator">Say "tap" twice with your tempo</div>
                <div class="tap-count" id="tapCount">Ready for voice tap</div>
            </div>

            <!-- Timer -->
            <div class="timer-section">
                <h3 class="section-title" style="font-size: 1.1em;">Practice Timer</h3>
                <div class="timer-display">
                    <div class="time-display" id="timeDisplay">00:00</div>
                    <div class="time-subtext" id="timeSubtext">Say "set timer for 2 minutes"</div>
                </div>
                <div class="controls">
                    <button class="control-btn" id="timerStartBtn">‚ñ∂Ô∏è Start</button>
                    <button class="control-btn" id="timerPauseBtn">‚è∏Ô∏è Pause</button>
                    <button class="control-btn" id="timerResumeBtn">‚èØÔ∏è Resume</button>
                    <button class="control-btn" id="timerCancelBtn">‚èπÔ∏è Cancel</button>
                </div>
                <div class="timer-inputs">
                    <input class="timer-text" id="timerQuickInput" placeholder="e.g., 2:00 or 90s" />
                    <button class="control-btn" id="timerSetBtn">Set</button>
                </div>
            </div>

            <!-- Voice Commands Help -->
            <div class="voice-commands-help">
                <h3 class="section-title" style="font-size: 1.1em;">Voice Commands</h3>
                <div class="command-category">
                    <h4>METRONOME:</h4>
                    <div class="command-list">"start" ‚Ä¢ "stop" ‚Ä¢ "120" ‚Ä¢ "faster" ‚Ä¢ "slower"</div>
                </div>
                <div class="command-category">
                    <h4>SUBDIVISIONS:</h4>
                    <div class="command-list">"quarter notes" ‚Ä¢ "eighth notes" ‚Ä¢ "triplets" ‚Ä¢ "sixteenth notes"</div>
                </div>
                <div class="command-category">
                    <h4>SHEET MUSIC:</h4>
                    <div class="command-list">"next page" ‚Ä¢ "previous page" ‚Ä¢ "go to page 3" ‚Ä¢ "flip every 4 bars"</div>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <!-- PDF Viewer -->
            <div class="pdf-section">
                <h2 class="section-title">Sheet Music</h2>
                <div class="pdf-controls">
                    <div class="page-info">
                        Page <span id="currentPage">1</span> of <span id="totalPages">1</span>
                    </div>
                </div>
                <div class="pdf-viewer" id="pdfViewer">
                    <div id="pdfContent"></div>
                    <div class="pdf-upload-area">
                        <div class="pdf-upload-icon">üìÑ</div>
                        <div class="upload-instruction">Voice-Controlled Sheet Music</div>
                        <div class="upload-description">
                            Upload a PDF to control page turning entirely by voice.
                            Say "next page", "previous page", or "go to page 3" while playing drums.
                        </div>
                        <button class="voice-only-note" onclick="document.getElementById('pdfInput').click()">
                            üìÅ Choose PDF File
                        </button>
                        <input type="file" id="pdfInput" accept=".pdf" class="hidden-input">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Console Log -->
    <div class="console-section">
        <div class="console-title">Live Voice Processing Log</div>
        <div id="consoleLog"></div>
    </div>

    <!--
            Notes (quick reference):
            - This single-file frontend contains the UI and the client-side logic
                (class VoiceOnlyDrumAssistant) that listens for voice commands, sends
                them to the backend (`/api/process-command`), and falls back to local
                regex parsing if the backend/AI is unavailable.

            - High-level UI pieces:
                * Left panel: voice controls, metronome display, tap-tempo hints
                * Right panel: PDF viewer and upload area (uses pdf.js dynamically)
                * Console section: shows a short, live log of voice processing events
                * Status bar: shows AI and voice status and last command

            - Data flow (simplified):
                1. User clicks mic button -> starts Web Speech API recognition
                2. Recognition result -> `processVoiceCommand(command)`
                3. `sendToAIBackend(command)` attempts to use backend AI (/api/process-command)
                     - on success: `normalizeIntent(result)` -> `executeIntent(intent)`
                     - on failure: `processWithPatterns(command)` -> `executeIntent(intent)`

            - Important DOM elements (by id):
                * `micButton`, `voiceStatusText` ‚Äî voice UI controls
                * `bpmDisplay`, `beatIndicator`, `subdivisionDisplay` ‚Äî metronome UI
                * `pdfInput`, `pdfContent`, `currentPage`, `totalPages` ‚Äî PDF UI
                * `consoleLog` ‚Äî live event log

            - Where to look if something breaks:
                * Browser console (voice API errors, audio context issues)
                * Server logs (backend AI errors and /api endpoints)
                * The live console in the UI (helpful event traces)
        -->

    <div class="status-bar">
        <div class="status-indicator">
            <div class="status-dot" id="aiStatus"></div>
            <span>AI Processing</span>
        </div>
        <div class="status-indicator">
            <div class="status-dot" id="voiceDot"></div>
            <span>Voice Recognition</span>
        </div>
        <div>
            Last Command: <span id="lastCommand">Ready for voice commands...</span>
        </div>
    </div>

    <script>
        // VoiceOnlyDrumAssistant
        // - Handles voice capture (Web Speech API), UI updates (metronome & PDF viewer),
        //   and coordination between frontend parsing (regex) and backend AI.
        // - Public properties (important):
        //   * bpm, subdivision, isPlaying
        //   * pdfDocument, currentPage, totalPages
        //   * recognition (SpeechRecognition instance)
        // - Key methods:
        //   * setupVoiceRecognition() - initializes Web Speech API and microphone button
        //   * processVoiceCommand(command) - top-level command handler
        //   * sendToAIBackend(command) - POSTs to /api/process-command and returns parsed result
        //   * processWithPatterns(command) - local fallback parser (server also has regex fallback)
        //   * executeIntent(intent) - applies parsed actions to local UI/state
        class VoiceOnlyDrumAssistant {
            constructor() {
                // Core state
                this.bpm = 120;
                this.subdivision = 'eighth';
                this.isPlaying = false;
                this.currentBeat = 0;
                this.metronomeInterval = null;
                this.beatsPerBar = 4;
                this.logicalTick = 0;

                // PDF state
                this.currentPage = 1;
                this.totalPages = 1;
                this.pdfDocument = null;
                this.pageSchedule = null;

                // Tap tempo
                this.tapTimes = [];

                // Timer state
                this.timerDurationMs = 0;      // total duration set
                this.timerRemainingMs = 0;     // remaining at any moment
                this.timerEndAt = null;        // Date.now() when it should end (if running)
                this.timerIntervalId = null;   // interval handle
                this.timerRunning = false;     // whether countdown is active
                this.timerPaused = false;      // whether paused

                // Stopwatch state (optional if you want count-up practice tracking now)
                this.swStartAt = null;
                this.swElapsedMs = 0;
                this.swIntervalId = null;
                this.swRunning = false;
                this.swPaused = false;

                // Voice recognition
                this.isListening = false;
                this.recognition = null;

                // Audio context for metronome sound
                this.audioCtx = null;

                this.initializeElements();
                this.setupEventListeners();
                this.setupVoiceRecognition();
                this.logMessage('System Ready', 'Voice-only drum assistant initialized');
            }

            initializeElements() {
                this.micButton = document.getElementById('micButton');
                this.bpmDisplay = document.getElementById('bpmDisplay');
                this.beatIndicator = document.getElementById('beatIndicator');
                this.subdivisionDisplay = document.getElementById('subdivisionDisplay');
                this.consoleLog = document.getElementById('consoleLog');
                this.currentPageEl = document.getElementById('currentPage');
                this.totalPagesEl = document.getElementById('totalPages');
                this.lastCommandEl = document.getElementById('lastCommand');
                this.aiStatusEl = document.getElementById('aiStatus');
                this.voiceDotEl = document.getElementById('voiceDot');
                this.voiceStatusTextEl = document.getElementById('voiceStatusText');
                this.playBtn = document.getElementById('playBtn');
                this.stopBtn = document.getElementById('stopBtn');

                // Tap tempo elements
                this.tapIndicator = document.getElementById('tapIndicator');
                this.tapCount = document.getElementById('tapCount');

                // Timer elements
                this.timeDisplayEl = document.getElementById('timeDisplay');
                this.timeSubtextEl = document.getElementById('timeSubtext');
                // Debug element to show last matched intent/pattern (created if missing)
                this.debugIntentEl = document.getElementById('debugIntent');
                if (!this.debugIntentEl) {
                    this.debugIntentEl = document.createElement('div');
                    this.debugIntentEl.id = 'debugIntent';
                    this.debugIntentEl.style.fontSize = '0.8em';
                    this.debugIntentEl.style.color = '#666';
                    this.timeSubtextEl.parentNode.appendChild(this.debugIntentEl);
                }
                this.timerStartBtn = document.getElementById('timerStartBtn');
                this.timerPauseBtn = document.getElementById('timerPauseBtn');
                this.timerResumeBtn = document.getElementById('timerResumeBtn');
                this.timerCancelBtn = document.getElementById('timerCancelBtn');
                this.timerQuickInput = document.getElementById('timerQuickInput');
                this.timerSetBtn = document.getElementById('timerSetBtn');
            }

            setupEventListeners() {
                this.playBtn.addEventListener('click', () => this.startMetronome());
                this.stopBtn.addEventListener('click', () => this.stopMetronome());
                // Timer controls (optional click helpers; voice also works)
                this.timerSetBtn.addEventListener('click', () => {
                    const text = (this.timerQuickInput.value || '').trim();
                    const ms = this.parseDurationToMs(text);
                    if (ms > 0) {
                        this.setTimer(ms);
                        this.logMessage('Timer Set', `Duration set to ${this.formatMs(ms)}`);
                    } else {
                        this.logMessage('Timer Error', 'Could not parse duration');
                    }
                });
                this.timerStartBtn.addEventListener('click', () => this.startTimer());
                this.timerPauseBtn.addEventListener('click', () => this.pauseTimer());
                this.timerResumeBtn.addEventListener('click', () => this.resumeTimer());
                this.timerCancelBtn.addEventListener('click', () => this.cancelTimer());
            }



            // setupVoiceRecognition()
            // - Initializes the Web Speech API (SpeechRecognition).
            // - Hooks recognition callbacks (.onstart, .onresult, .onerror, .onend)
            // - Toggles `isListening` and updates `micButton` UI state.
            // - Listens continuously to allow hands-free commands.
            setupVoiceRecognition() {
                const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SR) {
                    this.logMessage('Error', 'Voice recognition not supported - use Chrome or Edge browser');
                    this.voiceStatusTextEl.textContent = 'Voice not supported - use Chrome or Edge';
                    return;
                }

                this.recognition = new SR();
                this.recognition.continuous = true;
                this.recognition.interimResults = false;
                this.recognition.lang = 'en-US';

                this.recognition.onstart = () => {
                    this.isListening = true;
                    this.micButton.classList.add('recording');
                    this.voiceStatusTextEl.textContent = 'Listening for voice commands...';
                    this.voiceDotEl.classList.add('online');
                    this.logMessage('Voice Active', 'Ready for commands');
                };

                this.recognition.onresult = (event) => {
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const result = event.results[i];
                        if (result.isFinal && result[0]) {
                            const command = result[0].transcript.trim().toLowerCase();
                            this.logMessage('Voice Command', `"${command}"`);
                            this.lastCommandEl.textContent = command;
                            this.processVoiceCommand(command);
                        }
                    }
                };

                this.recognition.onerror = (event) => {
                    this.logMessage('Voice Error', event.error || 'Recognition error');
                    if (this.isListening && ['no-speech', 'network', 'aborted'].includes(event.error)) {
                        setTimeout(() => {
                            if (this.isListening) {
                                try { this.recognition.start(); } catch (e) { }
                            }
                        }, 1000);
                    }
                };

                this.recognition.onend = () => {
                    if (this.isListening) {
                        try {
                            this.recognition.start();
                        } catch (e) {
                            this.logMessage('Voice Error', 'Recognition restarting...');
                            setTimeout(() => {
                                if (this.isListening) {
                                    try { this.recognition.start(); } catch (e) { }
                                }
                            }, 1000);
                        }
                    } else {
                        this.micButton.classList.remove('recording');
                        this.voiceStatusTextEl.textContent = 'Click microphone to start voice control';
                        this.voiceDotEl.classList.remove('online');
                        this.logMessage('Voice Stopped', 'Voice control deactivated');
                    }
                };

                // Microphone button toggle
                this.micButton.addEventListener('click', () => {
                    if (this.isListening) {
                        this.isListening = false;
                        try { this.recognition.stop(); } catch (e) { }
                    } else {
                        this.isListening = true;
                        try {
                            this.recognition.start();
                        } catch (e) {
                            this.logMessage('Voice Error', 'Could not start voice recognition');
                            this.isListening = false;
                        }
                    }
                });
            }

            // processVoiceCommand(command)
            // - Top-level handler invoked when speech recognition returns a final transcript.
            // - Tries AI backend first (async). If that fails, falls back to the local pattern matcher.
            // - The resolved intent should be an object containing `action` and optional params.
            processVoiceCommand(command) {
                // Try AI backend first
                this.sendToAIBackend(command)
                    .then(result => {
                        const intent = this.normalizeIntent(result);
                        this.executeIntent(intent);
                    })
                    .catch(() => {
                        // Fallback to reliable regex patterns
                        this.processWithPatterns(command);
                    });
            }

            // sendToAIBackend(command) -> Promise<object>
            // - Posts the command to `/api/process-command` and returns parsed JSON from server.
            // - On failure (network/500/etc) it throws so callers can fall back to local parsing.
            async sendToAIBackend(command) {
                try {
                    const response = await fetch('/api/process-command', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ command })
                    });

                    if (!response.ok) throw new Error('AI backend unavailable');

                    const result = await response.json();
                    this.aiStatusEl.classList.add('online');
                    this.logMessage('AI Processing', `${result.provider}: ${JSON.stringify(result)}`);
                    return result;
                } catch (error) {
                    this.aiStatusEl.classList.remove('online');
                    throw error;
                }
            }

            normalizeIntent(result) {
                if (!result || typeof result !== 'object') return { action: 'unknown' };

                // Handle different AI response formats
                if (result.action) return result;
                if (result.intent) return { action: result.intent, ...result.params };

                return { action: 'unknown' };
            }

            // processWithPatterns(command)
            // - Local, deterministic fallback used when the backend AI is unavailable.
            // - Mirrors server-side PatternProcessor behavior but runs in-browser for lower latency.
            // - If you update server-side regexes, consider keeping these in sync.
            processWithPatterns(command) {
                this.logMessage('Pattern Matching', 'Processing voice command');
                if (this.debugIntentEl) this.debugIntentEl.textContent = 'matching...';

                // METRONOME CONTROL
                // Require an explicit target (metronome/click/beat) so generic commands
                // like "start timer" don't accidentally trigger the metronome.
                if (/(?:\b(start|begin)\b).*\b(metronome|click|beat)\b/i.test(command) || /\bstart\s+(metronome|click|beat)\b/i.test(command)) {
                        if (this.debugIntentEl) this.debugIntentEl.textContent = JSON.stringify({ action: 'startMetronome' });
                        return this.executeIntent({ action: 'startMetronome' });
                }
                if (/(?:\b(stop|end|halt)\b).*\b(metronome|click|beat)\b/i.test(command) || /\bstop\s+(metronome|click|beat)\b/i.test(command)) {
                    return this.executeIntent({ action: 'stopMetronome' });
                }

                // BPM SETTING - direct numbers or with keywords
                const bpmMatch = command.match(/(\d{2,3})/);
                if (bpmMatch) {
                    const bpm = parseInt(bpmMatch[1]);
                    // Client clamps safe range - mirror server clamp in UI range for consistency
                    if (bpm >= 40 && bpm <= 300) {
                        return this.executeIntent({ action: 'setBpm', bpm: bpm });
                    }
                }

                // RELATIVE TEMPO
                if (/faster/i.test(command)) {
                    return this.executeIntent({ action: 'adjustBpm', change: 5 });
                }
                if (/slower/i.test(command)) {
                    return this.executeIntent({ action: 'adjustBpm', change: -5 });
                }

                // SUBDIVISIONS
                if (/quarter/i.test(command)) {
                    return this.executeIntent({ action: 'setSubdivision', subdivision: 'quarter' });
                }
                if (/eighth/i.test(command) || /\b8th\b/i) {
                    return this.executeIntent({ action: 'setSubdivision', subdivision: 'eighth' });
                }
                if (/triplet/i.test(command)) {
                    return this.executeIntent({ action: 'setSubdivision', subdivision: 'triplet' });
                }
                if (/sixteenth/i.test(command) || /\b16th\b/i) {
                    return this.executeIntent({ action: 'setSubdivision', subdivision: 'sixteenth' });
                }

                // PAGE NAVIGATION
                if (/next.*page/i.test(command) || /page.*next/i.test(command)) {
                    return this.executeIntent({ action: 'nextPage' });
                }
                if (/previous.*page/i.test(command) || /page.*previous/i.test(command) || /back/i.test(command)) {
                    return this.executeIntent({ action: 'previousPage' });
                }

                // GO TO SPECIFIC PAGE
                const pageMatch = command.match(/page\s*(\d+)/i);
                if (pageMatch) {
                    return this.executeIntent({ action: 'goToPage', page: parseInt(pageMatch[1]) });
                }

                // SCHEDULED PAGE TURNS
                const scheduleMatch = command.match(/flip.*?(\d+).*?bar/i);
                if (scheduleMatch) {
                    return this.executeIntent({ action: 'schedulePageTurn', bars: parseInt(scheduleMatch[1]) });
                }

                // TAP TEMPO
                if (/\btap\b/i.test(command)) {
                    return this.executeIntent({ action: 'tap' });
                }

                // TIMER: set duration (e.g., "set timer for 2 minutes 30 seconds", "set a 90 second timer")
                const setTimerMatch = command.match(/set\s+(?:a\s+)?(?:timer|countdown)\s+(?:for\s+)?(.+)/i);
                if (setTimerMatch) {
                    const ms = this.parseDurationToMs(setTimerMatch[1]);
                    if (ms > 0) {
                        this.setTimer(ms);
                        return this.executeIntent({ action: 'announce', text: `Timer set to ${this.formatMs(ms)}` });
                    }
                }

                // TIMER basic controls
                // Allow more natural phrases to start the timer. For single-word "start"/"go",
                // only treat as timer start if a duration has already been set on the client.
                    if (/(?:^(?:start|begin|go)\b).*?(?:timer|countdown)?/i.test(command) || /(?:start|begin)\s+(timer|countdown)/i.test(command) || /kick\s*off\s*(?:the\s*)?(?:timer|countdown)?/i.test(command)) {
                        // Decide whether 'start'/'go' should mean timer or metronome.
                        const mentionsTimer = /\b(timer|countdown)\b/i.test(command) || /kick\s*off/i.test(command);
                        const singleWordStart = /^(?:start|go|begin)\s*$/i.test(command.trim());
                        // If it explicitly mentions timer, or it's not a bare start and the client has a duration set, start timer.
                        if (mentionsTimer || ((this.timerDurationMs && this.timerDurationMs > 0) && !singleWordStart)) {
                            if (this.debugIntentEl) this.debugIntentEl.textContent = JSON.stringify({ action: 'startTimer' });
                            return this.executeIntent({ action: 'startTimer' });
                        }
                        // If it's a bare 'start'/'go' and there's no timer configured, treat as metronome start.
                        if (singleWordStart && !(this.timerDurationMs && this.timerDurationMs > 0)) {
                            return this.executeIntent({ action: 'startMetronome' });
                        }
                    }
                if (/pause\s+(timer|countdown)/i.test(command) || /pause timer/i.test(command)) {
                    return this.executeIntent({ action: 'pauseTimer' });
                }
                if (/(resume|continue)\s+(timer|countdown)/i.test(command) || /resume timer/i.test(command)) {
                    return this.executeIntent({ action: 'resumeTimer' });
                }
                if (/(cancel|stop|clear)\s+(timer|countdown)/i.test(command) || /cancel timer/i.test(command)) {
                    return this.executeIntent({ action: 'cancelTimer' });
                }
                if (/how (much )?time (is )?left/i.test(command) || /time left/i.test(command)) {
                    const left = this.timerRunning ? this.timerEndAt - Date.now() : this.timerRemainingMs;
                    const msg = left > 0 ? `${this.formatMs(left)} remaining` : 'No active timer';
                    this.timeSubtextEl.textContent = msg;
                    return this.executeIntent({ action: 'announce', text: msg });
                }

                // STOPWATCH / PRACTICE TIMER (count-up)
                if (/start\s+(stopwatch|practice)/i.test(command)) return this.executeIntent({ action: 'startStopwatch' });
                if (/pause\s+(stopwatch|practice)/i.test(command)) return this.executeIntent({ action: 'pauseStopwatch' });
                if (/(resume|continue)\s+(stopwatch|practice)/i.test(command)) return this.executeIntent({ action: 'resumeStopwatch' });
                if (/(stop|end|finish)\s+(stopwatch|practice)/i.test(command)) return this.executeIntent({ action: 'stopStopwatch' });

                this.logMessage('Unknown Command', 'Command not recognized');
            }

            // executeIntent(intent)
            // - Receives a normalized intent object (usually { action, ...params })
            // - Applies the action to local state (metronome or PDF viewer)
            // - The client expects these actions and keeps UI in sync with applied changes.
            executeIntent(intent) {
                this.logMessage('Executing', JSON.stringify(intent));

                switch (intent.action) {
                    case 'setBpm':
                        this.setBpm(intent.bpm);
                        break;
                    case 'adjustBpm':
                        this.setBpm(this.bpm + intent.change);
                        break;
                    case 'startMetronome':
                        this.startMetronome();
                        break;
                    case 'stopMetronome':
                        this.stopMetronome();
                        break;
                    case 'setSubdivision':
                        this.setSubdivision(intent.subdivision);
                        break;
                    case 'nextPage':
                        this.nextPage();
                        break;
                    case 'previousPage':
                        this.previousPage();
                        break;
                    case 'goToPage':
                        this.goToPage(intent.page);
                        break;
                    case 'schedulePageTurn':
                        this.schedulePageTurn(intent.bars);
                        break;
                    case 'tap':
                        this.handleVoiceTap();
                        break;
                    case 'startTimer':
                        this.startTimer();
                        break;
                    case 'setTimer':
                        // Server may return { action: 'setTimer', ms: NUMBER }
                        if (typeof intent.ms === 'number') {
                            this.setTimer(intent.ms);
                            // Optionally start immediately if caller requested
                            if (intent.start) this.startTimer();
                        }
                        break;
                    case 'timeLeft':
                        // Server asked client to report remaining time; announce current timer state
                        const left = this.timerRunning ? this.timerEndAt - Date.now() : this.timerRemainingMs;
                        const msg = left > 0 ? `${this.formatMs(left)} remaining` : 'No active timer';
                        this.timeSubtextEl.textContent = msg;
                        this.logMessage('Timer', `Reported time left: ${msg}`);
                        break;
                    case 'pauseTimer':
                        this.pauseTimer();
                        break;
                    case 'resumeTimer':
                        this.resumeTimer();
                        break;
                    case 'cancelTimer':
                        this.cancelTimer();
                        break;
                    case 'announce':
                        // no-op; UI updated by caller
                        break;

                    // (Only if you added stopwatch features right now)
                    case 'startStopwatch':
                        this.swStart();
                        break;
                    case 'pauseStopwatch':
                        this.swPause();
                        break;
                    case 'resumeStopwatch':
                        this.swResume();
                        break;
                    case 'stopStopwatch':
                        this.swStop();
                        break;
                }
            }

            // CORE METRONOME FUNCTIONS
            // Metronome lifecycle:
            // - setBpm(newBpm): adjust tempo, clamps to safe range and restarts metronome if playing.
            // - setSubdivision(subdivision): change ticks-per-beat multiplier and restart if playing.
            // - startMetronome(): calculates interval from bpm/subdivision and schedules tick via setInterval.
            // - stopMetronome(): clears interval and resets UI indicators.
            // Notes:
            // - Ticks-per-bar are computed as beatsPerBar * multiplier (multiplier from subdivision)
            // - For production, a more accurate clock (AudioContext scheduler or WebWorker) is recommended
            //   to avoid setInterval jitter; setInterval is good enough for prototyping and voice-driven control.
            setBpm(newBpm) {
                if (newBpm < 60) newBpm = 60;
                if (newBpm > 220) newBpm = 220;

                this.bpm = newBpm;
                this.bpmDisplay.textContent = this.bpm;

                if (this.isPlaying) {
                    this.stopMetronome();
                    this.startMetronome();
                }

                this.logMessage('BPM Set', `Tempo: ${this.bpm} BPM`);
            }

            setSubdivision(subdivision) {
                this.subdivision = subdivision;
                const names = {
                    'quarter': 'Quarter Notes',
                    'eighth': 'Eighth Notes',
                    'triplet': 'Triplets',
                    'sixteenth': 'Sixteenth Notes'
                };

                this.subdivisionDisplay.textContent = names[subdivision] || names.eighth;

                if (this.isPlaying) {
                    this.stopMetronome();
                    this.startMetronome();
                }

                this.logMessage('Subdivision', `Changed to ${subdivision} notes`);
            }

            startMetronome() {
                if (this.isPlaying) return;

                this.isPlaying = true;
                this.currentBeat = 0;
                this.logicalTick = 0;
                this.ensureAudioContext();
                this.playBtn.classList.add('active');

                const multipliers = { quarter: 1, eighth: 2, triplet: 3, sixteenth: 4 };
                const ticksPerMinute = this.bpm * multipliers[this.subdivision];
                const interval = 60000 / ticksPerMinute;

                this.metronomeInterval = setInterval(() => {
                    this.playBeat();
                }, interval);

                this.logMessage('Metronome Started', `${this.bpm} BPM, ${this.subdivision} notes`);
            }

            stopMetronome() {
                if (!this.isPlaying) return;

                this.isPlaying = false;
                this.playBtn.classList.remove('active');
                clearInterval(this.metronomeInterval);
                this.beatIndicator.classList.remove('flash', 'accent');

                this.logMessage('Metronome Stopped', 'Metronome deactivated');
            }

            // TAP TEMPO FUNCTIONALITY
            // VOICE TAP TEMPO - single tap sets tempo immediately
            handleVoiceTap() {
                const now = Date.now();
                if (this.tapTimes.length === 0) {
                    this.tapTimes.push(now);
                    this.tapCount.textContent = 'Say "tap" again to set tempo';
                    this.tapIndicator.textContent = 'üéØ First tap recorded - say "tap" again';
                    this.logMessage('Voice Tap', 'First tap recorded');
                    return;
                }
                const lastTap = this.tapTimes[this.tapTimes.length - 1];
                const interval = now - lastTap;
                const calculatedBpm = Math.round(60000 / interval);
                let newBpm = calculatedBpm;
                if (newBpm < 60) newBpm = 60;
                if (newBpm > 220) newBpm = 220;
                this.setBpm(newBpm);
                this.tapIndicator.textContent = `‚úÖ Tempo set to ${newBpm} BPM from your timing!`;
                this.tapCount.textContent = `Applied: ${newBpm} BPM`;
                this.tapTimes = [];
                setTimeout(() => {
                    this.tapIndicator.textContent = 'Say "tap" to instantly set tempo from your timing';
                    this.tapCount.textContent = 'Ready for voice tap';
                }, 3000);
                this.logMessage('Voice Tap Applied', `Set tempo to ${newBpm} BPM from voice timing`);
            }

            playBeat() {
                this.currentBeat++;
                this.logicalTick++;

                // Visual beat indication
                const multipliers = { quarter: 1, eighth: 2, triplet: 3, sixteenth: 4 };
                const ticksPerBar = this.beatsPerBar * multipliers[this.subdivision];
                const isAccent = (this.logicalTick % ticksPerBar) === 1;

                this.beatIndicator.classList.remove('flash', 'accent');
                setTimeout(() => {
                    this.beatIndicator.classList.add(isAccent ? 'accent' : 'flash');
                }, 10);
                setTimeout(() => {
                    this.beatIndicator.classList.remove('flash', 'accent');
                }, 150);

                // Audio click
                this.playClick(isAccent);

                // Handle scheduled page turns
                if (this.pageSchedule) {
                    const barsComplete = Math.floor(this.logicalTick / ticksPerBar);
                    if (barsComplete > 0 && (barsComplete % this.pageSchedule.bars) === 0) {
                        this.nextPage();
                        this.logMessage('Auto Page Turn', `Turned after ${this.pageSchedule.bars} bars`);
                    }
                }
            }

            ensureAudioContext() {
                // ensureAudioContext()
                // - Lazily creates an AudioContext used for click sounds.
                // - Many browsers require a user gesture before audio can play; the code attempts to
                //   resume suspended contexts automatically.
                // - If audio initialization fails, the metronome will still run visually but without sound.
                if (!this.audioCtx) {
                    try {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        this.audioCtx = new AudioContext();

                        // Resume audio context if suspended (required for some browsers)
                        if (this.audioCtx.state === 'suspended') {
                            this.audioCtx.resume();
                        }

                        this.logMessage('Audio System', 'Audio context initialized');
                    } catch (error) {
                        this.logMessage('Audio Error', 'Could not initialize audio system');
                    }
                }
            }

            playClick(accent = false) {
                this.ensureAudioContext();
                if (!this.audioCtx || this.audioCtx.state !== 'running') {
                    // Try to resume if suspended
                    if (this.audioCtx && this.audioCtx.state === 'suspended') {
                        this.audioCtx.resume();
                    }
                    return;
                }

                try {
                    const now = this.audioCtx.currentTime;

                    // Create oscillator for the click sound
                    const osc = this.audioCtx.createOscillator();
                    const gainNode = this.audioCtx.createGain();

                    // Connect audio nodes
                    osc.connect(gainNode);
                    gainNode.connect(this.audioCtx.destination);

                    // Configure sound
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(accent ? 1000 : 800, now);

                    // Volume envelope for click sound
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(accent ? 0.3 : 0.2, now + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

                    // Play the sound
                    osc.start(now);
                    osc.stop(now + 0.1);

                } catch (error) {
                    console.error('Audio playback error:', error);
                }
            }

            // ===== TIMER IMPLEMENTATION =====
            setTimer(ms) {
                this.timerDurationMs = ms;
                this.timerRemainingMs = ms;
                this.timerPaused = false;
                this.timerRunning = false;
                this.timerEndAt = null;
                this.updateTimerDisplay(ms);
                this.timeSubtextEl.textContent = 'Timer ready. Say "start timer"';
                this.logMessage('Timer', `Set duration ${this.formatMs(ms)} (${ms}ms)`);
            }

            startTimer() {
                this.logMessage('Timer', `Start requested - durationMs=${this.timerDurationMs}, running=${this.timerRunning}, paused=${this.timerPaused}`);
                if (this.timerDurationMs <= 0) {
                    this.timeSubtextEl.textContent = 'Set a duration first (e.g., "set timer for 2 minutes")';
                    return;
                }
                if (this.timerRunning && !this.timerPaused) return;

                const now = Date.now();
                if (this.timerPaused) {
                    this.timerEndAt = now + this.timerRemainingMs;
                } else {
                    this.timerEndAt = now + this.timerDurationMs;
                    this.timerRemainingMs = this.timerDurationMs;
                }

                this.timerRunning = true;
                this.timerPaused = false;
                this.timeSubtextEl.textContent = 'Timer running‚Ä¶';

                clearInterval(this.timerIntervalId);
                this.timerIntervalId = setInterval(() => this.timerTick(), 200);
                this.logMessage('Timer', `Started: ${this.formatMs(this.timerRemainingMs)}`);
            }

            pauseTimer() {
                if (!this.timerRunning || this.timerPaused) return;
                this.timerPaused = true;
                this.timerRunning = false;
                clearInterval(this.timerIntervalId);
                this.timerRemainingMs = Math.max(0, this.timerEndAt - Date.now());
                this.timeSubtextEl.textContent = 'Timer paused';
                this.logMessage('Timer', `Paused at ${this.formatMs(this.timerRemainingMs)}`);
            }

            resumeTimer() {
                if (!this.timerPaused || this.timerRemainingMs <= 0) return;
                this.timerPaused = false;
                this.timerRunning = true;
                this.timerEndAt = Date.now() + this.timerRemainingMs;
                clearInterval(this.timerIntervalId);
                this.timerIntervalId = setInterval(() => this.timerTick(), 200);
                this.timeSubtextEl.textContent = 'Timer running‚Ä¶';
                this.logMessage('Timer', 'Resumed');
            }

            cancelTimer() {
                clearInterval(this.timerIntervalId);
                this.timerIntervalId = null;
                this.timerRunning = false;
                this.timerPaused = false;
                this.timerRemainingMs = 0;
                this.timerEndAt = null;
                this.updateTimerDisplay(0);
                this.timeSubtextEl.textContent = 'Timer cancelled';
                this.logMessage('Timer', 'Cancelled');
            }

            timerTick() {
                const now = Date.now();
                const remaining = Math.max(0, this.timerEndAt - now);
                this.timerRemainingMs = remaining;
                this.updateTimerDisplay(remaining);

                if (remaining <= 0) {
                    clearInterval(this.timerIntervalId);
                    this.timerIntervalId = null;
                    this.timerRunning = false;
                    this.timerPaused = false;
                    this.timeSubtextEl.textContent = '‚è∞ Time\'s up!';
                    this.onTimerComplete();
                    this.logMessage('Timer', "Completed");
                }
            }

            onTimerComplete() {
                // Play a short triple-accent for visibility
                this.ensureAudioContext();
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => this.playClick(true), i * 180);
                }
            }

            updateTimerDisplay(ms) {
                this.timeDisplayEl.textContent = this.formatMs(ms);
            }

            formatMs(ms) {
                const total = Math.round(ms / 1000);
                const m = Math.floor(total / 60);
                const s = total % 60;
                return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            }

            // Accepts inputs like "2:00", "90s", "2m 30s", "1 minute 15 seconds", "75"
            parseDurationToMs(text) {
                if (!text) return 0;
                const t = text.trim().toLowerCase();

                // mm:ss
                const mmss = t.match(/^(\d{1,3}):(\d{1,2})$/);
                if (mmss) {
                    const m = parseInt(mmss[1], 10);
                    const s = parseInt(mmss[2], 10);
                    if (!isNaN(m) && !isNaN(s)) return (m * 60 + s) * 1000;
                }

                // Xh Ym Zs or any subset
                let hours = 0, mins = 0, secs = 0;
                const hMatch = t.match(/(\d+)\s*h(ours?)?/);
                const mMatch = t.match(/(\d+)\s*m(in(ute)?s?)?/);
                const sMatch = t.match(/(\d+)\s*s(ec(ond)?s?)?/);
                if (hMatch || mMatch || sMatch) {
                    if (hMatch) hours = parseInt(hMatch[1], 10);
                    if (mMatch) mins = parseInt(mMatch[1], 10);
                    if (sMatch) secs = parseInt(sMatch[1], 10);
                    const total = (hours * 3600 + mins * 60 + secs) * 1000;
                    if (total > 0) return total;
                }

                // Plain number = seconds
                const plain = t.match(/^(\d{1,5})\s*$/);
                if (plain) {
                    return parseInt(plain[1], 10) * 1000;
                }

                return 0;
            }

            // VOICE TAP TEMPO - single tap sets tempo immediately
            handleVoiceTap() {
                const now = Date.now();

                // If this is the first tap, just record it
                if (this.tapTimes.length === 0) {
                    this.tapTimes.push(now);
                    this.tapCount.textContent = 'Say "tap" again to set tempo';
                    this.tapIndicator.textContent = 'üéØ First tap recorded - say "tap" again';
                    this.logMessage('Voice Tap', 'First tap recorded');
                    return;
                }

                // Calculate BPM from the interval between last tap and this one
                const lastTap = this.tapTimes[this.tapTimes.length - 1];
                const interval = now - lastTap;
                const calculatedBpm = Math.round(60000 / interval);

                // Clamp to reasonable range
                let newBpm = calculatedBpm;
                if (newBpm < 60) newBpm = 60;
                if (newBpm > 220) newBpm = 220;

                // Apply the tempo immediately
                this.setBpm(newBpm);

                // Update display
                this.tapIndicator.textContent = `‚úÖ Tempo set to ${newBpm} BPM from your timing!`;
                this.tapCount.textContent = `Applied: ${newBpm} BPM`;

                // Reset for next time
                this.tapTimes = [];

                setTimeout(() => {
                    this.tapIndicator.textContent = 'Say "tap" to instantly set tempo from your timing';
                    this.tapCount.textContent = 'Ready for voice tap';
                }, 3000);

                this.logMessage('Voice Tap Applied', `Set tempo to ${newBpm} BPM from voice timing`);
            }

            // PAGE NAVIGATION
            // PDF handling & page navigation:
            // - loadPDF(event): reads the File, loads pdf.js if necessary, and caches the PDFDocument.
            // - renderPage(pageNumber): renders into an offscreen canvas and inserts it into #pdfContent.
            // - nextPage()/previousPage()/goToPage(n): update `currentPage` and call renderPage.
            // Notes:
            // - Uses pdf.js CDN for simplicity; consider bundling a pinned pdf.js version for offline use.
            // - Rendering uses a scale factor (2.0) for high-res images; adjust for performance on low-end devices.
            schedulePageTurn(bars) {
                this.pageSchedule = { bars };
                this.logMessage('Page Schedule', `Will auto-turn every ${bars} bars`);
            }

            goToPage(pageNumber) {
                if (pageNumber >= 1 && pageNumber <= this.totalPages) {
                    this.currentPage = pageNumber;
                    this.currentPageEl.textContent = this.currentPage;
                    if (this.pdfDocument) {
                        this.renderPage(this.currentPage);
                    }
                    this.logMessage('Page Jump', `Jumped to page ${this.currentPage}`);
                } else {
                    this.logMessage('Page Error', `Page ${pageNumber} doesn't exist`);
                }
            }

            nextPage() {
                if (this.currentPage < this.totalPages) {
                    this.currentPage++;
                    this.currentPageEl.textContent = this.currentPage;
                    if (this.pdfDocument) {
                        this.renderPage(this.currentPage);
                    }
                    this.logMessage('Page Turn', `Next ‚Üí Page ${this.currentPage}`);
                } else {
                    this.logMessage('Page Limit', 'Already on last page');
                }
            }

            previousPage() {
                if (this.currentPage > 1) {
                    this.currentPage--;
                    this.currentPageEl.textContent = this.currentPage;
                    if (this.pdfDocument) {
                        this.renderPage(this.currentPage);
                    }
                    this.logMessage('Page Turn', `Previous ‚Üí Page ${this.currentPage}`);
                } else {
                    this.logMessage('Page Limit', 'Already on first page');
                }
            }

            // PDF HANDLING
            async loadPDF(event) {
                const file = event.target.files[0];
                if (!file || file.type !== 'application/pdf') {
                    this.logMessage('File Error', 'Please select a valid PDF file');
                    return;
                }

                this.logMessage('PDF Loading', `Loading: ${file.name}`);

                try {
                    if (typeof pdfjsLib === 'undefined') {
                        await this.loadPDFLibrary();
                    }

                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;

                    this.totalPages = pdf.numPages;
                    this.currentPage = 1;
                    this.pdfDocument = pdf;

                    this.totalPagesEl.textContent = this.totalPages;
                    this.currentPageEl.textContent = this.currentPage;

                    await this.renderPage(this.currentPage);
                    this.logMessage('PDF Loaded', `${this.totalPages} pages ready for voice control`);

                } catch (error) {
                    console.error('PDF loading error:', error);
                    this.logMessage('PDF Error', 'Failed to load PDF - try a different file');
                }
            }

            async loadPDFLibrary() {
                return new Promise((resolve, reject) => {
                    if (typeof pdfjsLib !== 'undefined') {
                        resolve();
                        return;
                    }

                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
                    script.onload = () => {
                        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                        resolve();
                    };
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            }

            async renderPage(pageNumber) {
                if (!this.pdfDocument) return;

                try {
                    const page = await this.pdfDocument.getPage(pageNumber);
                    const scale = 2.0; // Higher quality rendering
                    const viewport = page.getViewport({ scale });

                    let canvas = document.getElementById('pdfCanvas');
                    if (!canvas) {
                        canvas = document.createElement('canvas');
                        canvas.id = 'pdfCanvas';
                        canvas.style.cssText = `
                            max-width: 100%;
                            height: auto;
                            border: 1px solid #444;
                            border-radius: 8px;
                            background: white;
                            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
                        `;

                        const pdfContent = document.getElementById('pdfContent');
                        pdfContent.innerHTML = '';
                        pdfContent.appendChild(canvas);
                        pdfContent.style.cssText = `
                            display: flex;
                            justify-content: center;
                            align-items: flex-start;
                            padding: 15px;
                            overflow: auto;
                            width: 100%;
                            height: 100%;
                            background: #ffffff;
                        `;

                        // Hide the upload area completely when PDF is loaded
                        const uploadArea = document.querySelector('.pdf-upload-area');
                        if (uploadArea && uploadArea !== pdfContent.parentElement) {
                            uploadArea.style.display = 'none';
                        }
                    }

                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    const renderContext = {
                        canvasContext: context,
                        viewport: viewport
                    };

                    await page.render(renderContext).promise;
                    this.logMessage('Page Rendered', `Displaying page ${pageNumber}`);

                } catch (error) {
                    console.error('Page rendering error:', error);
                    this.logMessage('Render Error', `Could not display page ${pageNumber}`);
                }
            }

            logMessage(category, message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = 'console-log';
                logEntry.innerHTML = `
                    <div class="log-timestamp">[${timestamp}]</div>
                    <div class="log-command">${category}</div>
                    <div class="log-action">${message}</div>
                `;

                this.consoleLog.appendChild(logEntry);
                this.consoleLog.scrollTop = this.consoleLog.scrollHeight;

                // Prevent console from getting too long
                while (this.consoleLog.children.length > 30) {
                    this.consoleLog.removeChild(this.consoleLog.firstChild);
                }
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.drumAssistant = new VoiceOnlyDrumAssistant();

            // Set up PDF file input handler
            document.getElementById('pdfInput').addEventListener('change', (event) => {
                window.drumAssistant.loadPDF(event);
            });

            // Add some helpful startup messages
            setTimeout(() => {
                const assistant = window.drumAssistant;
                assistant.logMessage('Ready', 'Click microphone and say "start metronome"');
                assistant.logMessage('Voice Commands', 'All features controlled by voice only');
                assistant.logMessage('Timer', 'Say "set timer for 2 minutes" then "start timer"');
            }, 500);
        });
    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DrumVoice - Voice-Only Assistant for Drummers</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #0f1419 0%, #0a0e13 70%, #040608 100%);
            color: #e8f4f8;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            font-weight: 300;
        }

        .header {
            background: rgba(15, 20, 25, 0.95);
            padding: 20px 24px;
            text-align: center;
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 215, 0, 0.15);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        .header h1 {
            font-size: 2.4em;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffc107 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .header p {
            opacity: 0.8;
            font-size: 1.1em;
            font-weight: 400;
            color: #b8d4da;
        }

        .main-container {
            display: flex;
            flex: 1;
            gap: 20px;
            padding: 20px;
            min-height: 0;
        }

        .left-panel {
            width: 420px;
            background: rgba(25, 35, 45, 0.6);
            border-radius: 12px;
            padding: 30px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 215, 0, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .right-panel {
            flex: 1;
            background: rgba(25, 35, 45, 0.6);
            border-radius: 12px;
            padding: 24px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 215, 0, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .section-title {
            font-size: 1.3em;
            font-weight: 500;
            color: #ffd700;
            margin-bottom: 20px;
            text-align: center;
            letter-spacing: 0.5px;
        }

        .voice-control {
            text-align: center;
        }

        .mic-button {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 50%, #1d4ed8 100%);
            color: white;
            font-size: 3em;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 12px 35px rgba(59, 130, 246, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        .mic-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, transparent 0%, rgba(255, 215, 0, 0.1) 50%, transparent 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mic-button:hover {
            transform: translateY(-4px);
            box-shadow: 0 16px 45px rgba(59, 130, 246, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .mic-button:hover::before {
            opacity: 1;
        }

        .mic-button.recording {
            background: linear-gradient(135deg, #dc2626 0%, #ef4444 50%, #b91c1c 100%);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }

            70% {
                box-shadow: 0 0 0 25px rgba(239, 68, 68, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        .voice-status {
            font-size: 1.1em;
            color: #94a3b8;
            margin-top: 15px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .metronome-section {
            text-align: center;
        }

        .metronome-display {
            background: rgba(15, 20, 25, 0.8);
            padding: 30px;
            border-radius: 15px;
            margin: 20px 0;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .bpm-display {
            font-size: 3.5em;
            font-weight: 700;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .beat-indicator {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: rgba(30, 41, 59, 0.8);
            margin: 20px auto;
            transition: all 0.15s ease;
            border: 3px solid rgba(71, 85, 105, 0.5);
            box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .beat-indicator.flash {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            border-color: #3b82f6;
            box-shadow: 0 0 25px rgba(59, 130, 246, 0.6), inset 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .beat-indicator.accent {
            background: linear-gradient(135deg, #ffd700 0%, #f59e0b 100%);
            border-color: #ffd700;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.6), inset 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .subdivision-display {
            font-size: 1.1em;
            color: #94a3b8;
            margin-top: 15px;
            font-weight: 400;
        }

        .tap-tempo-section {
            text-align: center;
            background: rgba(15, 20, 25, 0.5);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.1);
        }

        .tap-indicator {
            font-size: 1.2em;
            margin: 12px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #cbd5e1;
            text-align: center;
        }

        .tap-count {
            font-size: 1em;
            color: #94a3b8;
        }

        .controls {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: rgba(30, 41, 59, 0.7);
            color: #e2e8f0;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: all 0.2s ease;
            border: 1px solid rgba(71, 85, 105, 0.3);
            backdrop-filter: blur(10px);
        }

        .control-btn:hover {
            background: rgba(51, 65, 85, 0.8);
            border-color: rgba(255, 215, 0, 0.3);
            transform: translateY(-1px);
        }


        .control-btn.active {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            border-color: #3b82f6;
            color: white;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .voice-commands-help {
            background: rgba(15, 20, 25, 0.6);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.1);
        }

        .command-category {
            margin-bottom: 15px;
        }

        .command-category h4 {
            color: #ffd700;
            font-size: 0.9em;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .command-list {
            color: #cbd5e1;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .pdf-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .pdf-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px 0;
        }

        .page-info {
            font-size: 1.2em;
            color: #ffd700;
            font-weight: 500;
            text-align: center;
        }

        .pdf-viewer {
            flex: 1;
            border-radius: 10px;
            overflow: hidden;
            background: rgba(15, 20, 25, 0.8);
            border: 1px solid rgba(255, 215, 0, 0.2);
            position: relative;
            min-height: 400px;
        }

        .pdf-upload-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            gap: 25px;
            color: #64748b;
            padding: 40px;
        }

        .pdf-upload-icon {
            font-size: 4em;
            opacity: 0.6;
        }

        .upload-instruction {
            font-size: 1.3em;
            font-weight: 500;
            color: #cbd5e1;
            text-align: center;
        }

        .upload-description {
            font-size: 1em;
            color: #64748b;
            text-align: center;
            max-width: 350px;
            line-height: 1.5;
        }

        .voice-only-note {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            padding: 15px 25px;
            border-radius: 25px;
            color: white;
            font-weight: 500;
            font-size: 1em;
            text-align: center;
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3);
        }

        #pdfContent {
            width: 100%;
            height: 100%;
            display: none;
            overflow: auto;
            background: #ffffff;
        }

        #pdfCanvas {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .console-section {
            background: rgba(15, 20, 25, 0.9);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            max-height: 250px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', 'Fira Code', 'Courier New', monospace;
            border: 1px solid rgba(255, 215, 0, 0.1);
        }

        .console-title {
            color: #ffd700;
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .console-log {
            margin-bottom: 10px;
            padding: 8px 0;
            border-left: 3px solid rgba(59, 130, 246, 0.4);
            padding-left: 15px;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .log-timestamp {
            color: #64748b;
            font-size: 0.8em;
        }

        .log-command {
            color: #fbbf24;
            margin: 3px 0;
            font-weight: 500;
        }

        .log-action {
            color: #60a5fa;
            margin: 3px 0;
        }

        .status-bar {
            background: rgba(15, 20, 25, 0.95);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid rgba(255, 215, 0, 0.15);
            font-size: 1em;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #94a3b8;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #475569;
            transition: background 0.3s ease;
        }

        .status-dot.online {
            background: #10b981;
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.4);
        }

        #lastCommand {
            color: #cbd5e1;
            font-style: italic;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 1.1em;
        }

        .hidden-input {
            position: absolute;
            left: -9999px;
            opacity: 0;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(15, 20, 25, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 215, 0, 0.5);
        }

        /* Mobile Responsiveness */
        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
                gap: 15px;
            }

            .left-panel {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>🥁 DrumVoice</h1>
        <p>Voice-Only Assistant for Professional Drummers</p>
    </div>

    <div class="main-container">
        <div class="left-panel">
            <!-- Voice Control -->
            <div class="voice-control">
                <h2 class="section-title">Voice Control</h2>
                <button class="mic-button" id="micButton">🎤</button>
                <div class="voice-status" id="voiceStatusText">Click microphone to start voice control</div>
            </div>

            <!-- Metronome -->
            <div class="metronome-section">
                <h2 class="section-title">Metronome</h2>
                <div class="metronome-display">
                    <div class="bpm-display" id="bpmDisplay">120</div>
                    <div class="beat-indicator" id="beatIndicator"></div>
                    <div class="subdivision-display" id="subdivisionDisplay">Eighth Notes</div>
                </div>

                <div class="controls">
                    <button class="control-btn" id="playBtn">▶️ Start</button>
                    <button class="control-btn" id="stopBtn">⏹️ Stop</button>
                </div>
            </div>

            <!-- Tap Tempo Section -->
            <div class="tap-tempo-section">
                <h3 class="section-title" style="font-size: 1.1em;">Tap Tempo (by voice)</h3>
                <div class="tap-indicator" id="tapIndicator">Say "tap" twice with your tempo</div>
                <div class="tap-count" id="tapCount">Ready for voice tap</div>
            </div>

            <!-- Voice Commands Help -->
            <div class="voice-commands-help">
                <h3 class="section-title" style="font-size: 1.1em;">Voice Commands</h3>
                <div class="command-category">
                    <h4>METRONOME:</h4>
                    <div class="command-list">"start" • "stop" • "120" • "faster" • "slower"</div>
                </div>
                <div class="command-category">
                    <h4>SUBDIVISIONS:</h4>
                    <div class="command-list">"quarter notes" • "eighth notes" • "triplets" • "sixteenth notes"</div>
                </div>
                <div class="command-category">
                    <h4>SHEET MUSIC:</h4>
                    <div class="command-list">"next page" • "previous page" • "go to page 3" • "flip every 4 bars"</div>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <!-- PDF Viewer -->
            <div class="pdf-section">
                <h2 class="section-title">Sheet Music</h2>
                <div class="pdf-controls">
                    <div class="page-info">
                        Page <span id="currentPage">1</span> of <span id="totalPages">1</span>
                    </div>
                </div>
                <div class="pdf-viewer" id="pdfViewer">
                    <div class="pdf-upload-area">
                        <div class="pdf-upload-icon">📄</div>
                        <div class="upload-instruction">Voice-Controlled Sheet Music</div>
                        <div class="upload-description">
                            Upload a PDF to control page turning entirely by voice.
                            Say "next page", "previous page", or "go to page 3" while playing drums.
                        </div>
                        <button class="voice-only-note" onclick="document.getElementById('pdfInput').click()">
                            📁 Choose PDF File
                        </button>
                        <input type="file" id="pdfInput" accept=".pdf" class="hidden-input">
                        <div id="pdfContent"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Console Log -->
    <div class="console-section">
        <div class="console-title">Live Voice Processing Log</div>
        <div id="consoleLog"></div>
    </div>

    <div class="status-bar">
        <div class="status-indicator">
            <div class="status-dot" id="aiStatus"></div>
            <span>AI Processing</span>
        </div>
        <div class="status-indicator">
            <div class="status-dot" id="voiceDot"></div>
            <span>Voice Recognition</span>
        </div>
        <div>
            Last Command: <span id="lastCommand">Ready for voice commands...</span>
        </div>
    </div>

    <script>
        class VoiceOnlyDrumAssistant {
            constructor() {
                // Core state
                this.bpm = 120;
                this.subdivision = 'eighth';
                this.isPlaying = false;
                this.currentBeat = 0;
                this.metronomeInterval = null;
                this.beatsPerBar = 4;
                this.logicalTick = 0;

                // PDF state
                this.currentPage = 1;
                this.totalPages = 1;
                this.pdfDocument = null;
                this.pageSchedule = null;

                // Tap tempo
                this.tapTimes = [];

                // Voice recognition
                this.isListening = false;
                this.recognition = null;

                // Audio context for metronome sound
                this.audioCtx = null;

                this.initializeElements();
                this.setupEventListeners();
                this.setupVoiceRecognition();
                this.logMessage('System Ready', 'Voice-only drum assistant initialized');
            }

            initializeElements() {
                this.micButton = document.getElementById('micButton');
                this.bpmDisplay = document.getElementById('bpmDisplay');
                this.beatIndicator = document.getElementById('beatIndicator');
                this.subdivisionDisplay = document.getElementById('subdivisionDisplay');
                this.consoleLog = document.getElementById('consoleLog');
                this.currentPageEl = document.getElementById('currentPage');
                this.totalPagesEl = document.getElementById('totalPages');
                this.lastCommandEl = document.getElementById('lastCommand');
                this.aiStatusEl = document.getElementById('aiStatus');
                this.voiceDotEl = document.getElementById('voiceDot');
                this.voiceStatusTextEl = document.getElementById('voiceStatusText');
                this.playBtn = document.getElementById('playBtn');
                this.stopBtn = document.getElementById('stopBtn');

                // Tap tempo elements
                this.tapIndicator = document.getElementById('tapIndicator');
                this.tapCount = document.getElementById('tapCount');
            }

            setupEventListeners() {
                this.playBtn.addEventListener('click', () => this.startMetronome());
                this.stopBtn.addEventListener('click', () => this.stopMetronome());
            }

            setupVoiceRecognition() {
                const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SR) {
                    this.logMessage('Error', 'Voice recognition not supported - use Chrome or Edge browser');
                    this.voiceStatusTextEl.textContent = 'Voice not supported - use Chrome or Edge';
                    return;
                }

                this.recognition = new SR();
                this.recognition.continuous = true;
                this.recognition.interimResults = false;
                this.recognition.lang = 'en-US';

                this.recognition.onstart = () => {
                    this.isListening = true;
                    this.micButton.classList.add('recording');
                    this.voiceStatusTextEl.textContent = 'Listening for voice commands...';
                    this.voiceDotEl.classList.add('online');
                    this.logMessage('Voice Active', 'Ready for commands');
                };

                this.recognition.onresult = (event) => {
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const result = event.results[i];
                        if (result.isFinal && result[0]) {
                            const command = result[0].transcript.trim().toLowerCase();
                            this.logMessage('Voice Command', `"${command}"`);
                            this.lastCommandEl.textContent = command;
                            this.processVoiceCommand(command);
                        }
                    }
                };

                this.recognition.onerror = (event) => {
                    this.logMessage('Voice Error', event.error || 'Recognition error');
                    if (this.isListening && ['no-speech', 'network', 'aborted'].includes(event.error)) {
                        setTimeout(() => {
                            if (this.isListening) {
                                try { this.recognition.start(); } catch (e) { }
                            }
                        }, 1000);
                    }
                };

                this.recognition.onend = () => {
                    if (this.isListening) {
                        try {
                            this.recognition.start();
                        } catch (e) {
                            this.logMessage('Voice Error', 'Recognition restarting...');
                            setTimeout(() => {
                                if (this.isListening) {
                                    try { this.recognition.start(); } catch (e) { }
                                }
                            }, 1000);
                        }
                    } else {
                        this.micButton.classList.remove('recording');
                        this.voiceStatusTextEl.textContent = 'Click microphone to start voice control';
                        this.voiceDotEl.classList.remove('online');
                        this.logMessage('Voice Stopped', 'Voice control deactivated');
                    }
                };

                // Microphone button toggle
                this.micButton.addEventListener('click', () => {
                    if (this.isListening) {
                        this.isListening = false;
                        try { this.recognition.stop(); } catch (e) { }
                    } else {
                        this.isListening = true;
                        try {
                            this.recognition.start();
                        } catch (e) {
                            this.logMessage('Voice Error', 'Could not start voice recognition');
                            this.isListening = false;
                        }
                    }
                });
            }

            processVoiceCommand(command) {
                // Try AI backend first
                this.sendToAIBackend(command)
                    .then(result => {
                        const intent = this.normalizeIntent(result);
                        this.executeIntent(intent);
                    })
                    .catch(() => {
                        // Fallback to reliable regex patterns
                        this.processWithPatterns(command);
                    });
            }

            async sendToAIBackend(command) {
                try {
                    const response = await fetch('/api/process-command', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ command })
                    });

                    if (!response.ok) throw new Error('AI backend unavailable');

                    const result = await response.json();
                    this.aiStatusEl.classList.add('online');
                    this.logMessage('AI Processing', `${result.provider}: ${JSON.stringify(result)}`);
                    return result;
                } catch (error) {
                    this.aiStatusEl.classList.remove('online');
                    throw error;
                }
            }

            normalizeIntent(result) {
                if (!result || typeof result !== 'object') return { action: 'unknown' };

                // Handle different AI response formats
                if (result.action) return result;
                if (result.intent) return { action: result.intent, ...result.params };

                return { action: 'unknown' };
            }

            processWithPatterns(command) {
                this.logMessage('Pattern Matching', 'Processing voice command');

                // METRONOME CONTROL
                if (/start/i.test(command)) {
                    return this.executeIntent({ action: 'startMetronome' });
                }
                if (/stop/i.test(command)) {
                    return this.executeIntent({ action: 'stopMetronome' });
                }

                // BPM SETTING - direct numbers or with keywords
                const bpmMatch = command.match(/(\d{2,3})/);
                if (bpmMatch) {
                    const bpm = parseInt(bpmMatch[1]);
                    if (bpm >= 60 && bpm <= 220) {
                        return this.executeIntent({ action: 'setBpm', bpm: bpm });
                    }
                }

                // RELATIVE TEMPO
                if (/faster/i.test(command)) {
                    return this.executeIntent({ action: 'adjustBpm', change: 5 });
                }
                if (/slower/i.test(command)) {
                    return this.executeIntent({ action: 'adjustBpm', change: -5 });
                }

                // SUBDIVISIONS
                if (/quarter/i.test(command)) {
                    return this.executeIntent({ action: 'setSubdivision', subdivision: 'quarter' });
                }
                if (/eighth/i.test(command)) {
                    return this.executeIntent({ action: 'setSubdivision', subdivision: 'eighth' });
                }
                if (/triplet/i.test(command)) {
                    return this.executeIntent({ action: 'setSubdivision', subdivision: 'triplet' });
                }
                if (/sixteenth/i.test(command)) {
                    return this.executeIntent({ action: 'setSubdivision', subdivision: 'sixteenth' });
                }

                // PAGE NAVIGATION
                if (/next.*page/i.test(command) || /page.*next/i.test(command)) {
                    return this.executeIntent({ action: 'nextPage' });
                }
                if (/previous.*page/i.test(command) || /page.*previous/i.test(command) || /back/i.test(command)) {
                    return this.executeIntent({ action: 'previousPage' });
                }

                // GO TO SPECIFIC PAGE
                const pageMatch = command.match(/page\s*(\d+)/i);
                if (pageMatch) {
                    return this.executeIntent({ action: 'goToPage', page: parseInt(pageMatch[1]) });
                }

                // SCHEDULED PAGE TURNS
                const scheduleMatch = command.match(/flip.*?(\d+).*?bar/i);
                if (scheduleMatch) {
                    return this.executeIntent({ action: 'schedulePageTurn', bars: parseInt(scheduleMatch[1]) });
                }

                // TAP TEMPO
                if (/\btap\b/i.test(command)) {
                    return this.executeIntent({ action: 'tap' });
                }

                this.logMessage('Unknown Command', 'Command not recognized');
            }

            executeIntent(intent) {
                this.logMessage('Executing', JSON.stringify(intent));

                switch (intent.action) {
                    case 'setBpm':
                        this.setBpm(intent.bpm);
                        break;
                    case 'adjustBpm':
                        this.setBpm(this.bpm + intent.change);
                        break;
                    case 'startMetronome':
                        this.startMetronome();
                        break;
                    case 'stopMetronome':
                        this.stopMetronome();
                        break;
                    case 'setSubdivision':
                        this.setSubdivision(intent.subdivision);
                        break;
                    case 'nextPage':
                        this.nextPage();
                        break;
                    case 'previousPage':
                        this.previousPage();
                        break;
                    case 'goToPage':
                        this.goToPage(intent.page);
                        break;
                    case 'schedulePageTurn':
                        this.schedulePageTurn(intent.bars);
                        break;
                    case 'tap':
                        this.handleVoiceTap();
                        break;
                }
            }

            // CORE METRONOME FUNCTIONS
            setBpm(newBpm) {
                if (newBpm < 60) newBpm = 60;
                if (newBpm > 220) newBpm = 220;

                this.bpm = newBpm;
                this.bpmDisplay.textContent = this.bpm;

                if (this.isPlaying) {
                    this.stopMetronome();
                    this.startMetronome();
                }

                this.logMessage('BPM Set', `Tempo: ${this.bpm} BPM`);
            }

            setSubdivision(subdivision) {
                this.subdivision = subdivision;
                const names = {
                    'quarter': 'Quarter Notes',
                    'eighth': 'Eighth Notes',
                    'triplet': 'Triplets',
                    'sixteenth': 'Sixteenth Notes'
                };

                this.subdivisionDisplay.textContent = names[subdivision] || names.eighth;

                if (this.isPlaying) {
                    this.stopMetronome();
                    this.startMetronome();
                }

                this.logMessage('Subdivision', `Changed to ${subdivision} notes`);
            }

            startMetronome() {
                if (this.isPlaying) return;

                this.isPlaying = true;
                this.currentBeat = 0;
                this.logicalTick = 0;
                this.ensureAudioContext();
                this.playBtn.classList.add('active');

                const multipliers = { quarter: 1, eighth: 2, triplet: 3, sixteenth: 4 };
                const ticksPerMinute = this.bpm * multipliers[this.subdivision];
                const interval = 60000 / ticksPerMinute;

                this.metronomeInterval = setInterval(() => {
                    this.playBeat();
                }, interval);

                this.logMessage('Metronome Started', `${this.bpm} BPM, ${this.subdivision} notes`);
            }

            stopMetronome() {
                if (!this.isPlaying) return;

                this.isPlaying = false;
                this.playBtn.classList.remove('active');
                clearInterval(this.metronomeInterval);
                this.beatIndicator.classList.remove('flash', 'accent');

                this.logMessage('Metronome Stopped', 'Metronome deactivated');
            }

            // TAP TEMPO FUNCTIONALITY
            // VOICE TAP TEMPO - single tap sets tempo immediately
            handleVoiceTap() {
                const now = Date.now();
                if (this.tapTimes.length === 0) {
                    this.tapTimes.push(now);
                    this.tapCount.textContent = 'Say "tap" again to set tempo';
                    this.tapIndicator.textContent = '🎯 First tap recorded - say "tap" again';
                    this.logMessage('Voice Tap', 'First tap recorded');
                    return;
                }
                const lastTap = this.tapTimes[this.tapTimes.length - 1];
                const interval = now - lastTap;
                const calculatedBpm = Math.round(60000 / interval);
                let newBpm = calculatedBpm;
                if (newBpm < 60) newBpm = 60;
                if (newBpm > 220) newBpm = 220;
                this.setBpm(newBpm);
                this.tapIndicator.textContent = `✅ Tempo set to ${newBpm} BPM from your timing!`;
                this.tapCount.textContent = `Applied: ${newBpm} BPM`;
                this.tapTimes = [];
                setTimeout(() => {
                    this.tapIndicator.textContent = 'Say "tap" to instantly set tempo from your timing';
                    this.tapCount.textContent = 'Ready for voice tap';
                }, 3000);
                this.logMessage('Voice Tap Applied', `Set tempo to ${newBpm} BPM from voice timing`);
            }

            playBeat() {
                this.currentBeat++;
                this.logicalTick++;

                // Visual beat indication
                const multipliers = { quarter: 1, eighth: 2, triplet: 3, sixteenth: 4 };
                const ticksPerBar = this.beatsPerBar * multipliers[this.subdivision];
                const isAccent = (this.logicalTick % ticksPerBar) === 1;

                this.beatIndicator.classList.remove('flash', 'accent');
                setTimeout(() => {
                    this.beatIndicator.classList.add(isAccent ? 'accent' : 'flash');
                }, 10);
                setTimeout(() => {
                    this.beatIndicator.classList.remove('flash', 'accent');
                }, 150);

                // Audio click
                this.playClick(isAccent);

                // Handle scheduled page turns
                if (this.pageSchedule) {
                    const barsComplete = Math.floor(this.logicalTick / ticksPerBar);
                    if (barsComplete > 0 && (barsComplete % this.pageSchedule.bars) === 0) {
                        this.nextPage();
                        this.logMessage('Auto Page Turn', `Turned after ${this.pageSchedule.bars} bars`);
                    }
                }
            }

            ensureAudioContext() {
                if (!this.audioCtx) {
                    try {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        this.audioCtx = new AudioContext();

                        // Resume audio context if suspended (required for some browsers)
                        if (this.audioCtx.state === 'suspended') {
                            this.audioCtx.resume();
                        }

                        this.logMessage('Audio System', 'Audio context initialized');
                    } catch (error) {
                        this.logMessage('Audio Error', 'Could not initialize audio system');
                    }
                }
            }

            playClick(accent = false) {
                this.ensureAudioContext();
                if (!this.audioCtx || this.audioCtx.state !== 'running') {
                    // Try to resume if suspended
                    if (this.audioCtx && this.audioCtx.state === 'suspended') {
                        this.audioCtx.resume();
                    }
                    return;
                }

                try {
                    const now = this.audioCtx.currentTime;

                    // Create oscillator for the click sound
                    const osc = this.audioCtx.createOscillator();
                    const gainNode = this.audioCtx.createGain();

                    // Connect audio nodes
                    osc.connect(gainNode);
                    gainNode.connect(this.audioCtx.destination);

                    // Configure sound
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(accent ? 1000 : 800, now);

                    // Volume envelope for click sound
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(accent ? 0.3 : 0.2, now + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

                    // Play the sound
                    osc.start(now);
                    osc.stop(now + 0.1);

                } catch (error) {
                    console.error('Audio playback error:', error);
                }
            }

            // VOICE TAP TEMPO - single tap sets tempo immediately
            handleVoiceTap() {
                const now = Date.now();

                // If this is the first tap, just record it
                if (this.tapTimes.length === 0) {
                    this.tapTimes.push(now);
                    this.tapCount.textContent = 'Say "tap" again to set tempo';
                    this.tapIndicator.textContent = '🎯 First tap recorded - say "tap" again';
                    this.logMessage('Voice Tap', 'First tap recorded');
                    return;
                }

                // Calculate BPM from the interval between last tap and this one
                const lastTap = this.tapTimes[this.tapTimes.length - 1];
                const interval = now - lastTap;
                const calculatedBpm = Math.round(60000 / interval);

                // Clamp to reasonable range
                let newBpm = calculatedBpm;
                if (newBpm < 60) newBpm = 60;
                if (newBpm > 220) newBpm = 220;

                // Apply the tempo immediately
                this.setBpm(newBpm);

                // Update display
                this.tapIndicator.textContent = `✅ Tempo set to ${newBpm} BPM from your timing!`;
                this.tapCount.textContent = `Applied: ${newBpm} BPM`;

                // Reset for next time
                this.tapTimes = [];

                setTimeout(() => {
                    this.tapIndicator.textContent = 'Say "tap" to instantly set tempo from your timing';
                    this.tapCount.textContent = 'Ready for voice tap';
                }, 3000);

                this.logMessage('Voice Tap Applied', `Set tempo to ${newBpm} BPM from voice timing`);
            }

            // PAGE NAVIGATION
            schedulePageTurn(bars) {
                this.pageSchedule = { bars };
                this.logMessage('Page Schedule', `Will auto-turn every ${bars} bars`);
            }

            goToPage(pageNumber) {
                if (pageNumber >= 1 && pageNumber <= this.totalPages) {
                    this.currentPage = pageNumber;
                    this.currentPageEl.textContent = this.currentPage;
                    if (this.pdfDocument) {
                        this.renderPage(this.currentPage);
                    }
                    this.logMessage('Page Jump', `Jumped to page ${this.currentPage}`);
                } else {
                    this.logMessage('Page Error', `Page ${pageNumber} doesn't exist`);
                }
            }

            nextPage() {
                if (this.currentPage < this.totalPages) {
                    this.currentPage++;
                    this.currentPageEl.textContent = this.currentPage;
                    if (this.pdfDocument) {
                        this.renderPage(this.currentPage);
                    }
                    this.logMessage('Page Turn', `Next → Page ${this.currentPage}`);
                } else {
                    this.logMessage('Page Limit', 'Already on last page');
                }
            }

            previousPage() {
                if (this.currentPage > 1) {
                    this.currentPage--;
                    this.currentPageEl.textContent = this.currentPage;
                    if (this.pdfDocument) {
                        this.renderPage(this.currentPage);
                    }
                    this.logMessage('Page Turn', `Previous → Page ${this.currentPage}`);
                } else {
                    this.logMessage('Page Limit', 'Already on first page');
                }
            }

            // PDF HANDLING
            async loadPDF(event) {
                const file = event.target.files[0];
                if (!file || file.type !== 'application/pdf') {
                    this.logMessage('File Error', 'Please select a valid PDF file');
                    return;
                }

                this.logMessage('PDF Loading', `Loading: ${file.name}`);

                try {
                    if (typeof pdfjsLib === 'undefined') {
                        await this.loadPDFLibrary();
                    }

                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;

                    this.totalPages = pdf.numPages;
                    this.currentPage = 1;
                    this.pdfDocument = pdf;

                    this.totalPagesEl.textContent = this.totalPages;
                    this.currentPageEl.textContent = this.currentPage;

                    await this.renderPage(this.currentPage);
                    this.logMessage('PDF Loaded', `${this.totalPages} pages ready for voice control`);

                } catch (error) {
                    console.error('PDF loading error:', error);
                    this.logMessage('PDF Error', 'Failed to load PDF - try a different file');
                }
            }

            async loadPDFLibrary() {
                return new Promise((resolve, reject) => {
                    if (typeof pdfjsLib !== 'undefined') {
                        resolve();
                        return;
                    }

                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
                    script.onload = () => {
                        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                        resolve();
                    };
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            }

            async renderPage(pageNumber) {
                if (!this.pdfDocument) return;

                try {
                    const page = await this.pdfDocument.getPage(pageNumber);
                    const scale = 2.0; // Higher quality rendering
                    const viewport = page.getViewport({ scale });

                    let canvas = document.getElementById('pdfCanvas');
                    if (!canvas) {
                        canvas = document.createElement('canvas');
                        canvas.id = 'pdfCanvas';
                        canvas.style.cssText = `
                            max-width: 100%;
                            height: auto;
                            border: 1px solid #444;
                            border-radius: 8px;
                            background: white;
                            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
                        `;

                        const pdfContent = document.getElementById('pdfContent');
                        pdfContent.innerHTML = '';
                        pdfContent.appendChild(canvas);
                        pdfContent.style.cssText = `
                            display: flex;
                            justify-content: center;
                            align-items: flex-start;
                            padding: 15px;
                            overflow: auto;
                            width: 100%;
                            height: 100%;
                            background: #ffffff;
                        `;

                        // Hide the upload area completely when PDF is loaded
                        const uploadArea = document.querySelector('.pdf-upload-area');
                        if (uploadArea && uploadArea !== pdfContent.parentElement) {
                            uploadArea.style.display = 'none';
                        }
                    }

                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    const renderContext = {
                        canvasContext: context,
                        viewport: viewport
                    };

                    await page.render(renderContext).promise;
                    this.logMessage('Page Rendered', `Displaying page ${pageNumber}`);

                } catch (error) {
                    console.error('Page rendering error:', error);
                    this.logMessage('Render Error', `Could not display page ${pageNumber}`);
                }
            }

            logMessage(category, message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = 'console-log';
                logEntry.innerHTML = `
                    <div class="log-timestamp">[${timestamp}]</div>
                    <div class="log-command">${category}</div>
                    <div class="log-action">${message}</div>
                `;

                this.consoleLog.appendChild(logEntry);
                this.consoleLog.scrollTop = this.consoleLog.scrollHeight;

                // Prevent console from getting too long
                while (this.consoleLog.children.length > 30) {
                    this.consoleLog.removeChild(this.consoleLog.firstChild);
                }
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.drumAssistant = new VoiceOnlyDrumAssistant();

            // Set up PDF file input handler
            document.getElementById('pdfInput').addEventListener('change', (event) => {
                window.drumAssistant.loadPDF(event);
            });

            // Add some helpful startup messages
            setTimeout(() => {
                const assistant = window.drumAssistant;
                assistant.logMessage('Ready', 'Click microphone and say "start metronome"');
                assistant.logMessage('Voice Commands', 'All features controlled by voice only');
            }, 500);
        });
    </script>
</body>

</html>